#!/usr/bin/env python
#coding: iso-8859-15
#
# uptodate helps you to keep your system uptodate
#
# Copyright (C) 2005  Gaëtan Lehmann <gaetan.lehmann@jouy.inra.fr>
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#

VERSION = "0.3"


import gettext
gettext.install('uptodate')


USAGE="uptodate [options] command [options] [arguments]"

DESCRIPTION=_('''Commands:
%s
Run "uptodate command --help" for more information.

Exit codes:
%s
''')


import urllib
import re
import __builtin__
import sys
import os.path
from optparse import OptionParser, IndentedHelpFormatter

# python 2.3 compatibility
if sys.version < '2.4' :
	# set compatibility
	import sets
	set = sets.Set
	# sorted function
	def sorted(iterable, cmp=None, key=None, reverse=False) :
		i = list(iterable)
		if key :
			d = {}
			for v in iterable :
				k = key(v)
				if not d.has_key(k) :
					d[k] = []
				d[k].append(v)
			keys = d.keys()
			keys.sort(cmp)
			i = []
			for k in keys :
				i += d[k]
		else :
			i.sort(cmp)
		if reverse :
			i.reverse()
		return i
	

# error codes

ERROR_INVALID_NB_OF_ARGS = 1
ERROR_NO_VERSION_FOUND = 2
ERROR_MODULE_NOT_FOUND = 3
ERROR_PROPERTY_NOT_FOUND = 4
ERROR_MODULE_EXISTS = 5
ERROR_UNKNOWN_COMMAND = 6
ERROR_IO = 7
ERROR_KB_INTERRUPT = 8

ERRORS = {
	ERROR_INVALID_NB_OF_ARGS: _("Invalid number of arguments"),
	ERROR_NO_VERSION_FOUND: _("No version found"),
	ERROR_MODULE_NOT_FOUND: _("Module not found"),
	ERROR_PROPERTY_NOT_FOUND: _("Property not found"),
	ERROR_MODULE_EXISTS: _("Module already exists"),
	ERROR_UNKNOWN_COMMAND: _("Unknown command"),
	ERROR_IO: _("Input/Output error"),
	ERROR_KB_INTERRUPT: _("keyboard interrupt"),
}

# define uptodate internals exceptions

class InvalidNbOfArgs(Exception) :
	pass

class NoVersionFound(Exception) :
	pass

class ModuleNotFoundException(Exception) :
	pass

class ModuleExistsException(Exception) :
	pass

class UnknownCommandException(Exception) :
	pass

class PropertyNotFoundException(Exception) :
	pass


# following functions are commands
# first line of docstring is used as command short description
# next lines are used in command description

def commandAdd(argv, conf, out) :
	"Add a new module"
	parser = OptionParser(usage="uptodate [options] add [options] name url regexp [comment]\n", description=_(commandAdd.__doc__))
	parser.add_option("-b", "--batch", action="store_true", dest="batch", help=_("don't ask questions"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("add module even if it already exist"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("display added module"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("list avaible options"))
	opts, args = parser.parse_args(argv)

	if opts.listOption :
		listOptions(parser)
		return 0
    
	if len(args) < 3 :
		raise InvalidNbOfArgs(parser.get_usage())

	module = args[0]
	url = args[1]
	regexp = args[2]
	comment = " ".join(args[3:])
	
	if not opts.force and conf.has_section(module) :
		if opts.batch or not yes(_("Do you want to remove existing %s module?") % module, False) :
			raise ModuleExistsException(module)
		else :
			opts.force = True
	
	current = getVersions(module, url, regexp)
	
	# test if a version can be found
	if len(current) != 0 :
		if opts.force and conf.has_section(module) :
			conf.remove_section(module)
		conf.add_section(module)
		conf.set(module, 'url', url)
		conf.set(module, 'regexp', regexp)
		conf.set(module, 'comment', comment)
		conf.set(module, 'current', repr(current))
		
		if opts.verbose :
			printModule(conf, module, sys.stderr, True)
	else :
		# no version found... exit
		raise NoVersionFound()


def commandAuto(argv, conf, out) :
	"Search for a regexp and a new module"
	parser = OptionParser(usage="uptodate [options] auto [options] name url version [comment]""", description=_(commandAdd.__doc__))
	parser.add_option("-b", "--batch", action="store_true", dest="batch", help=_("don't ask questions"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("add module even if it already exist"))
	parser.add_option("-i", "--interactive", action="store_true", dest="choose", help=_("choose a regexp"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("display added module"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("list avaible options"))
	opts, args = parser.parse_args(argv)
	
	versionRegExp = r'([^<>\n\r]+)'

	if opts.listOption :
		listOptions(parser)
		return 0
    
	if len(args) < 3 :
		raise InvalidNbOfArgsException(parser.get_usage())

	module = args[0]
	url = args[1]
	version = args[2]
	comment = " ".join(args[3:])
	
	if not opts.force and conf.has_section(module) :
		if opts.batch or not yes(_("Do you want to remove existing %s module?") % module, False) :
			raise ModuleExistsException(module)
		else :
			opts.force = True
	
	# load data which will be used to search regexp
	urlData = loadData(url)

	# find text around version string given by user
	bordersRegexps = []
	# text is keep from version to ', " or < (or >, depending of side)
	# versin string is escaped to avoid problem with regexp. Without escape, "2.7.4" can match "217a4" for example.
	bordersRegexps.append(('', r'([>"\'][^>"\']*)%s([^>"]{0,15}[<"\'])', ''))
	# for ftp listing
	bordersRegexps.append((r'[drwxls\-]{10}\s+' + r'\S+\s+' * 7, r'(\S*)%s(\S*)', ''))
	# finally, use what we can find
	bordersRegexps.append(('', '(.*)%s(.*)', ''))
		
	borders = []
	# select borders
	for (prefix, bRegexp, suffix) in bordersRegexps :
		borders = re.findall(prefix + bRegexp % re.escape(version) + suffix, urlData)
		if borders != [] :
			break
	
	if len(borders) == 0 :
		raise NoVersionFound()

	# generate regexp candidates, and select the best one
	candidates = set()
	regexp = ""
	for border in borders :
		lBorder, rBorder = border
		
		# remove part of border if version is found in it
		if version in lBorder :
			lBorder = lBorder[lBorder.find(version)+len(version):]
		if version in rBorder :
			rBorder = rBorder[:lBorder.find(version)]
			
		# escape characters so they can be used in regexp
		lBorder = re.escape(lBorder)
		rBorder = re.escape(rBorder)
		
		# create regexp candidate
		candidate = prefix + lBorder + versionRegExp + rBorder + suffix
	
		# finally, add regexp candidate to the list
		candidates.add(candidate)


	# sort canditates
	# best candidates have the module name near the version
	# find candidates with module name in it
	bestCandidates = [c for c in candidates if module in c]
	# define a function able to give distance from module to version
	def disModuleVersion(s) :
		vPos = s.find(versionRegExp)
		mPos = s.find(module)
		if vPos > mPos :
			return vPos - (mPos + len(module))
		else :
			return mPos - (vPos + len(versionRegExp))

	# define another method which add -length, so it can be used as a second sort parameter (largest is the best)
	def lenModuleVersion(s) :
		return (disModuleVersion(s), -len(s))
	
	# use this second function to sort bestCandidates
	# don't use it for python 2.3 : bestCandidates.sort(key=lenModuleVersion)
	bestCandidates = sorted(bestCandidates, key=lenModuleVersion)

	# sort the other candidate (largest is the best)	
	otherCandidates = sorted(candidates - set(bestCandidates), key=len, reverse=True)

	candidates = bestCandidates + otherCandidates
	regexp = candidates[0]
	
	if opts.choose :
		# ask to user to select a regexp
		print >> sys.stderr, _("Avaible candidates: ")
		for i, candidate in enumerate(candidates) :
			print >> sys.stderr, "%i. %s" % (i, candidate)
			print >> sys.stderr, '    %s' % repr(re.findall(candidate, urlData))
			print >> sys.stderr
		# get number
		import readline
		selectRegExp = -1
		while selectRegExp == -1 :
			try :
			        userAnwser = raw_input(_("Choose a regexp candidate (0): "))
				selectRegExp = int(userAnwser)
				if selectRegExp < 0 or selectRegExp >= len(candidates) :
					selectRegExp = -1
			except ValueError :
				if userAnwser == "" :
				    selectRegExp = 0
			except EOFError :
				# transform EOF in keyboard interrupt
				raise KeyboardInterrupt()
		# replace automatically selected regexp with user one
		regexp = candidates[selectRegExp]

	# get versions founds with selected regexp
	current = list(set(re.findall(regexp, urlData)))

	# test if a version can be found
	if len(current) != 0 :
		if opts.force and conf.has_section(module) :
			conf.remove_section(module)
		conf.add_section(module)
		conf.set(module, 'url', url)
		conf.set(module, 'regexp', regexp)
		conf.set(module, 'comment', comment)
		conf.set(module, 'current', repr(current))
		
		if opts.verbose :
			printModule(conf, module, sys.stderr, True)
	else :
		# no version found... exit
		raise NoVersionFound()


def commandCheck(argv, conf, out) :
	"Check version"
	parser = OptionParser(usage="uptodate [options] check [options] [name] ...", description=_(commandCheck.__doc__))
	parser.add_option("-a", "--all", action="store_true", dest="all", help=_("check all modules"))
	parser.add_option("-A", "--added", action="store_true", dest="added", help=_("display added versions"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("ignore missing modules"))
	parser.add_option("-r", "--removed", action="store_true", dest="removed", help=_("display removed versions"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("display what is done"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("list avaible options and modules"))
	opts, args = parser.parse_args(argv)

	if opts.listOption :
		listOptions(parser)
		listModules(conf)
		return 0

    
	if not opts.added and not opts.removed :
		# by default, both removed and added are displayed
		opts.added = True
		opts.removed = True
	
	if len(args) == 0 and not opts.all :
		# no module to check... print usage and exit
		raise InvalidNbOfArgs(parser.get_usage())

	if opts.all :
		modules = conf.sections()
	else :
		modules = set(args)
		wrongModules = modules - set(conf.sections())
		if wrongModules :
			if opts.force :
				modules -= wrongModules
			else :
				raise ModuleNotFoundException(wrongModules)


	for module in sorted(modules) :
		if opts.verbose :
			print >> sys.stderr, _("Checking %s") % module
		# get module properties
		url = conf.get(module, 'url')
		regexp = conf.get(module, 'regexp').replace('\\\\', '\\')
		currentVersions = eval(conf.get(module, 'current'))
		# get new versions
		newVersions = getVersions(module, url, regexp)
		# test if a version can be found
		if len(newVersions) != 0 :
			conf.set(module, 'current', repr(newVersions))
			
			added = set(newVersions) - set(currentVersions)
			removed = set(currentVersions) - set(newVersions)
			if added and opts.added :
				print >> out, _("%s: %s added.") % (module, ", ".join(map(repr, added)))
			if removed and opts.removed :
				print >> out, _("%s: %s removed.") % (module, ", ".join(map(repr, removed)))
		else :
			# no version found ... exit
			print >> sys.stderr, _("Warning, no version found for %s. Nothing will be stored.") % module
			# return
		

def commandEdit(argv, conf, out) :
	"Edit module properties"
	parser = OptionParser(usage="uptodate [options] edit [options] name property [value]", description=_(commandEdit.__doc__))
	parser.add_option("-b", "--batch", action="store_true", dest="batch", help=_("don't ask questions"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("don't test if new value allows to find versions"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("display modified module"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("list avaible options and modules"))
	opts, args = parser.parse_args(argv)

	if opts.listOption :
		listOptions(parser)
		listModules(conf)
		return 0
    
	if len(args) == 2 and not opts.batch :
		# interactive edit
		module, prop = args
		if module not in conf.sections() :
			raise ModuleNotFoundException(module)
		if not conf.has_option(module, prop) :
			raise PropertyNotFound(prop)

		import readline
		# arghhh
		# readline.insert_text() seems to so nothing :-(
		# how to set an initial value ??
		readline.insert_text(conf.get(module, prop))
		value = raw_input(_('%s value : ') % prop)
		
	elif len(args) >= 3 :
		# command line edit
		module = args[0]
		prop = args[1]
		value = " ".join(args[2:])
		if module not in conf.sections() :
			raise ModuleNotFoundException(wrongModules)
		if not conf.has_option(module, prop) :
			raise PropertyNotFound(prop)
		
	else :
		# invalid number of arguments !
		raise InvalidNbOfArgs(parser.get_usage())
	
	# modify prop value
	conf.set(module, prop, value)
	if opts.verbose :
		printModule(conf, module, sys.stderr, True)

	# test if everything is ok
	if not opts.force and prop in ["regexp", "url"] :
		current = getVersions(module, conf.get(module, 'url'), conf.get(module, 'regexp'))
		if len(current) == 0 :
			raise NoVersionFound()
		conf.set(module, 'current', repr(current))



def commandRemove(argv, conf, out) :
	"Remove a module"
	parser = OptionParser(usage="uptodate [options] remove [options] [name] ...", description=_(commandRemove.__doc__))
	parser.add_option("-a", "--all", action="store_true", dest="all", help=_("remove all modules"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("remove modules without questions and ignore missing modules"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("display removed modules"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("list avaible options and modules"))
	opts, args = parser.parse_args(argv)

	if opts.listOption :
		listOptions(parser)
		listModules(conf)
		return 0

    
	if len(args) == 0 and not opts.all :
		raise InvalidNbOfArgs(parser.get_usage())
	
	if opts.all :
		modules = conf.sections()
	else :
		modules = set(args)
		wrongModules = modules - set(conf.sections())
		if wrongModules :
			if opts.force :
				modules -= wrongModules
			else :
				raise ModuleNotFoundException(wrongModules)


	for module in sorted(modules) :
		if opts.force or yes(_("Remove %s?") % module, False) :
			if opts.verbose :
				printModule(conf, module, sys.stderr, True)
			conf.remove_section(module)
		

def commandDisplay(argv, conf, out) :
	"Display configured modules"
	parser = OptionParser(usage="uptodate [options] display [options] [name] ...", description=_(commandDisplay.__doc__))
	parser.add_option("-a", "--all", action="store_true", dest="all", help=_("display all modules"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("ignore missing modules"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("display more info"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("list avaible options and modules"))
	opts, args = parser.parse_args(argv)

	if opts.listOption :
		listOptions(parser)
		listModules(conf)
		return 0
    
    
	if len(args) == 0 and not opts.all :
		raise InvalidNbOfArgs(parser.get_usage())
	
	if opts.all :
		modules = conf.sections()
	else :
		modules = set(args)
		wrongModules = modules - set(conf.sections())
		if wrongModules :
			if opts.force :
				modules -= wrongModules
			else :
				raise ModuleNotFoundException(wrongModules)


	for module in sorted(modules) :
		printModule(conf, module, out, opts.verbose)


def commandCopy(argv, conf, out) :
	"Copy a module"
	parser = OptionParser(usage="uptodate [options] copy name name", description=_(commandCopy.__doc__))
	parser.add_option("-b", "--batch", action="store_true", dest="batch", help=_("don't ask questions"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("copy module even if destination already exist"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("display copied module"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("list avaible options and modules"))
	opts, args = parser.parse_args(argv)

	if opts.listOption :
		listOptions(parser)
		listModules(conf)
		return 0
    
	if len(args) != 2 :
		raise InvalidNbOfArgs(parser.get_usage())

	module, new = args
	if module not in conf.sections() :
		raise ModuleNotFoundException(module)

	if not opts.force and conf.has_section(new) :
		if opts.batch or not yes(_("Do you want to remove existing %s module?") % new, False) :
			raise ModuleExistsException(new)
		else :
			opts.force = True
	
	# remove new section if it already exist and --force is used
	if opts.force and  conf.has_section(new) :
		conf.remove_section(new)

	conf.add_section(new)
	for prop in conf.options(module) :
		conf.set(new, prop, conf.get(module, prop))
	if opts.verbose :
		printModule(conf, new, sys.stderr, True)


	
	
def commandRename(argv, conf, out) :
	"Rename a module"
	parser = OptionParser(usage="uptodate [options] rename name newName", description=_(commandRename.__doc__))
	parser.add_option("-b", "--batch", action="store_true", dest="batch", help=_("don't ask questions"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("rename module even if new name already exist"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("display renamed module"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("list avaible options and modules"))
	opts, args = parser.parse_args(argv)

	if opts.listOption :
		listOptions(parser)
		listModules(conf)
		return 0
    
	if len(args) != 2 :
		raise InvalidNbOfArgs(parser.get_usage())

	module, new = args
	if module not in conf.sections() :
		raise ModuleNotFoundException(module)
	
	# remove new section if it already exist and --force is used
	if not opts.force and conf.has_section(new) :
		if opts.batch or not yes(_("Do you want to remove existing %s module?") % new, False) :
			raise ModuleExistsException(new)
		else :
			opts.force = True
	
	# remove new section if it already exist and --force is used
	if opts.force and  conf.has_section(new) :
		conf.remove_section(new)

	conf.add_section(new)
	for prop in conf.options(module) :
		conf.set(new, prop, conf.get(module, prop))
	conf.remove_section(module)
	if opts.verbose :
		printModule(conf, new, sys.stderr, True)

	
	
def commandImport(argv, conf, out) :
	"Import modules"
	parser = OptionParser(usage="uptodate [options] import filename [name] ...", description=_(commandRename.__doc__))
	parser.add_option("-a", "--all", action="store_true", dest="all", help=_("import all modules in filename"))
	parser.add_option("-b", "--batch", action="store_true", dest="batch", help=_("don't ask questions"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("import modules even if the module already exist"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("display imported module"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("list avaible options"))
	opts, args = parser.parse_args(argv)

	if opts.listOption :
		listOptions(parser)
		return 0
    
        # load config to import
	import ConfigParser
	importConf = ConfigParser.SafeConfigParser()
	importFile = file(args[0])
	importConf.readfp(importFile)
	importFile.close()

	# module to import
	if len(args) <= 1 and not opts.all :
		raise InvalidNbOfArgs(parser.get_usage())
	
	if opts.all :
		modules = importConf.sections()
	else :
		modules = set(args[1:])
		wrongModules = modules - set(importConf.sections())
		if wrongModules :
			if opts.force :
				modules -= wrongModules
			else :
				raise ModuleNotFoundException(wrongModules)
	
	
	# now iterate sections
	for module in sorted(modules) :
		imp = True
		if conf.has_section(module) :
			if opts.force :
				conf.remove_section(module)
			elif opts.batch :
				raise ModuleExistsException(module)
			elif yes(_("Do you want to remove existing %s module?") % module, False) :
				conf.remove_section(module)
			else :
				imp = False
		if imp :
			# copy section
			conf.add_section(module)
			for prop in importConf.options(module) :
				conf.set(module, prop, importConf.get(module, prop))
			if opts.verbose :
				printModule(conf, module, sys.stderr, True)

	return 0


	
	
def commandExport(argv, conf, out) :
	"Export modules"
	parser = OptionParser(usage="uptodate [options] export [name] ...", description=_(commandRename.__doc__))
	parser.add_option("-a", "--all", action="store_true", dest="all", help=_("export all modules"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("ignore missing modules"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("display exported module"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("list avaible options and modules"))
	opts, args = parser.parse_args(argv)

	if opts.listOption :
		listOptions(parser)
		listModules(conf)
		return 0
    
	import ConfigParser
	exportConf = ConfigParser.SafeConfigParser()

	if len(args) == 0 and not opts.all :
		raise InvalidNbOfArgs(parser.get_usage())
	
	if opts.all :
		modules = conf.sections()
	else :
		modules = set(args)
		wrongModules = modules - set(conf.sections())
		if wrongModules :
			if opts.force :
				modules -= wrongModules
			else :
				raise ModuleNotFoundException(wrongModules)
	
	
	# now iterate modules
	for module in sorted(modules) :
		# copy section
		exportConf.add_section(module)
		for prop in conf.options(module) :
			exportConf.set(module, prop, conf.get(module, prop))
		if opts.verbose :
			printModule(exportConf, module, sys.stderr, True)

	exportConf.write(out)
	return 0


	
	
COMMANDS = {'add': commandAdd,
	    'check': commandCheck,
	    'edit': commandEdit,
	    'remove': commandRemove,
	    'display': commandDisplay,
	    'copy': commandCopy,
	    'rename': commandRename,
	    'auto': commandAuto,
	    'import': commandImport,
	    'export': commandExport,
	    }




# helper functions

def printModule(conf, module, out, verbose=False) :
	"""
	printModule(conf, module, out, verbose)

	print module info to out file. Infos comes from conf object.
	"""
	url = conf.get(module, 'url')
	regexp = conf.get(module, 'regexp').replace('\\\\', '\\')
	current = conf.get(module, 'current')
	comment = conf.get(module, 'comment')
	
	if verbose :
		print >> out, module
		print >> out, _("\tcomment= ")+comment
		print >> out, _("\turl= ")+url
		print >> out, _("\tregexp= ")+regexp
		print >> out, _("\tcurrent= ")+current
	else :
		s = module
		if comment :
			s += " (%s)" % comment
		print >> out, s
		

def yes(question, default=None) :
	import readline
	if default != None and default :
		values = _('Y/n')
	elif default != None and not default :
		values = _('y/N')
	else :
		values = _('y/n')
		
	try :
		ret = raw_input("%s (%s) " % (question, values)).lower()
	except EOFError :
		# transform EOF in keyboard interrupt
		raise KeyboardInterrupt()
	
	if ret in [_("n"), _("no")] :
		return False
	if ret in [_("y"), _("yes")] :
		return True
	if default != None and ret == "" :
		return default
	# invalid answer... reask the question
	return yes(question, default)


def listOptions(parser) :
	for opt in parser.option_list :
		print opt._long_opts[0]


def listModules(conf) :
	for module in conf.sections() :
		print module
	

def loadData(url) :
    try :
	    urlFile = urllib.urlopen(url)
	    urlData = urlFile.read()
	    urlFile.close()
    except IOError, e :
	    if e.errno == 21 :
		    # url is a directory !
		    # we use 'ls -l' to have the same output than a ftp dir
		    import commands
		    (retVal, urlData) = commands.getstatusoutput('ls -l %s' % url)
		    if retVal != 0 :
			    # something goes wrong...
			    raise urlData
	    else :
		    # re-throw exception :-)
		    raise e
    return urlData


def getVersions(module, url, regexp) :
    urlData = loadData(url)
    new = re.findall(regexp, urlData)
    return list(set(new))



def file(fName, output=False, notNone=False, append=False) :
        """Renvoi un fichier en fonction du nom de fichier passé en paramètre.
        
        fName est le chemin d'acces complet a un fichier.
        fName = "-" est interprété comme l'entrée (ou la sortie, si output=True) standard.
        output = True indique que le ficher doit etre ouvert en ecriture
        notNone = True provoque le renvoi d'un fichier ouvert sur /dev/null plutot que None quand fName = ""
        append provoque l'ouverture du ficheir en mode append. Doit etre utilisé avec output = True
        """
        if append :
                wMode = "a"
        else :
                wMode = "w"
        
        #le nom de fichier est vide...
        if fName == "" :
                if notNone :
                        if output :
                                return file("/dev/null", wMode)
                        else :
                                return file("/dev/null")
                else :
                        return None
        
        elif fName == "-" :
                #la sortie ou l'entree standard
                if output :
                        return sys.stdout
                else :
                        return sys.stdin
        else :
                # un fichier normal
                if output :
                        return __builtin__.file(fName, wMode)
                else :
                        return __builtin__.file(fName)




class UptodateHelpFormatter(IndentedHelpFormatter) :
	def format_description(self, description):
		return description.strip()



def main(argv) :
	# generate command description
	comString = ""
	fill = max([len(c) for c in COMMANDS.keys()])
	for command in sorted(COMMANDS.keys()) :
		comString += _("  %s  %s\n") % (command.ljust(fill), COMMANDS[command].__doc__.splitlines()[0].strip())

	# generate exit code description
	errString = ""
	fill = max([len(str(c)) for c in ERRORS.keys()])
	for error in sorted(ERRORS.keys()) :
		errString += _("  %s  %s\n") % (str(error).ljust(fill), ERRORS[error])
		
	# generate complete description
	fullDesc = DESCRIPTION % (comString, errString)

	# and create option parser
	parser = OptionParser(usage=USAGE,
			      description=fullDesc,
			      version="uptodate %s" % VERSION,
			      formatter=UptodateHelpFormatter())
	parser.disable_interspersed_args()
	parser.add_option("-c", "--config-file", dest="configPath", default=os.path.expanduser("~/.uptodate"), metavar=_("FILE"), help=_("configuration file"))
	parser.add_option("-d", "--dry-run", action="store_true", dest="dryRun", help=_("do not modify config file"))
	parser.add_option("-o", "--output", dest="outputPath", default="-", metavar=_("FILE"), help=_("write output to FILE"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("list avaible options and commands"))
	opts, args = parser.parse_args()
    
	if opts.listOption :
		listOptions(parser)
		# also display commands !
		for command in COMMANDS :
			print command
		return
    
	if len(args) > 0 :
		command = args[0]
		args = args[1:]
		if command not in COMMANDS.keys() :
			raise UnknownCommandException(command)
	else:
		parser.print_usage()
		raise InvalidNbOfArgs()
	
	
	# load config in a file to be able to load it from stdin
	import ConfigParser
	conf = ConfigParser.SafeConfigParser()
	try :
		# try to load config
		confFile = file(opts.configPath)
	except :
		# load fail... try to create it
		file(opts.configPath, True).close()
		confFile = file(opts.configPath)
	conf.readfp(confFile)
	confFile.close()

	# set output file
	out = file(opts.outputPath, True)
	
	# execute command
	retVal = COMMANDS[command](args, conf, out)
	
	# save config file, if needed
	if not opts.dryRun :
		confFile = file(opts.configPath, 'w')
		conf.write(confFile)
		confFile.close()

	return 0






if __name__ == '__main__':
	import sys
	try :
		sys.exit(main(sys.argv[1:]))
		
	except IOError, e:
		sys.stderr.write(sys.argv[0]+": ")
		if e.filename :
			sys.stderr.write(e.filename+": ")
		sys.stderr.write(str(e.strerror)+"\n")
		sys.exit(ERROR_IO)

	except KeyboardInterrupt, e :
		sys.stderr.write(str(e)+"\n")
		sys.exit(ERROR_KB_INTERRUPT)
		
	except InvalidNbOfArgs, e :
		sys.exit(ERROR_INVALID_NB_OF_ARGS)

	except ModuleExistsException, e :
		print >> sys.stderr, _("Module %s already exists.") % e.args[0]
		sys.exit(ERROR_MODULE_EXISTS)

	except NoVersionFound, e :
		print >> sys.stderr, _("Error: no version found.")
		sys.exit(ERROR_NO_VERSION_FOUND)

	except ModuleNotFoundException, e :
		sing = _("Error: module %s not found")
		plur = _("Error: modules %s not found")
		last = _(" and ")
		sep = _(", ")
		args = e.args[0]
		if isinstance(args, str) :
			msg = sing % args
		elif len(args) == 1 :
			args = list(args)
			msg = sing % args[0]
		else :
			args = list(args)
			msg = plur % (sep.join(args[:-1])+last+args[-1])
		print >> sys.stderr, msg
		sys.exit(ERROR_MODULE_NOT_FOUND)

	except PropertyNotFoundException, e :
		print >> sys.stderr, _("Error: %s property doesn't exist.") % e.args[0]
		sys.exit(ERROR_PROPERTY_NOT_FOUND)



