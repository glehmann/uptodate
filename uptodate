#!/usr/bin/env python
#coding: iso-8859-15
#
# uptodate helps you to keep your system uptodate
#
# Copyright (C) 2005  Gaëtan Lehmann <gaetan.lehmann@jouy.inra.fr>
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#

VERSION = "0.3"


import gettext
gettext.install('uptodate')


USAGE="uptodate [options] commande [options] [arguments]"

DESCRIPTION=_('''uptodate vous permet de suivre les versions de tout ce qui a une version

uptodate est un programme en ligne de commande facile à utiliser qui vous aide à
savoir quand une nouvelle version est disponible. Il recherche les versions dans
une page web, un repertoire ftp, etc, et vous montre les versions ajoutées et
supprimées depuis la dernière recherche.
Si vous mettez à jour certains logiciels à la main, si vous êtes mainteneur de
paquetages (rpm, deb, ...), ou si vous voulez simplement savoir quand la
nouvelle version de votre jeu favori (ou de tout autre chose avec une version)
est disponible, uptodate est fait pour vous !

Auteur : Gaëtan Lehmann <gaetan.lehmann@jouy.inra.fr>
Site web: http://gleh.dyndns.org/uptodate/

Commandes :
%s
Executez "uptodate command --help" pour plus d\'informations.

Codes de sortie :
%s''')


import urllib
import re
import __builtin__
import sys
import os.path
from optparse import OptionParser, IndentedHelpFormatter

# python 2.3 compatibility
if sys.version < '2.4' :
	# set compatibility
	import sets
	set = sets.Set
	# sorted function
	def sorted(iterable, cmp=None, key=None, reverse=False) :
		i = list(iterable)
		if key :
			d = {}
			for v in iterable :
				k = key(v)
				if not d.has_key(k) :
					d[k] = []
				d[k].append(v)
			keys = d.keys()
			keys.sort(cmp)
			i = []
			for k in keys :
				i += d[k]
		else :
			i.sort(cmp)
		if reverse :
			i.reverse()
		return i
	

# error codes

ERROR_INVALID_NB_OF_ARGS = 1
ERROR_NO_VERSION_FOUND = 2
ERROR_MODULE_NOT_FOUND = 3
ERROR_PROPERTY_NOT_FOUND = 4
ERROR_MODULE_EXISTS = 5
ERROR_UNKNOWN_COMMAND = 6
ERROR_IO = 7
ERROR_KB_INTERRUPT = 8

ERRORS = {
	ERROR_INVALID_NB_OF_ARGS: _("Nombre d'arguments invalide"),
	ERROR_NO_VERSION_FOUND: _("Aucune version trouvée"),
	ERROR_MODULE_NOT_FOUND: _("Impossible de trouver le module"),
	ERROR_PROPERTY_NOT_FOUND: _("Impossible de trouver la propriété"),
	ERROR_MODULE_EXISTS: _("Le module existe déjà"),
	ERROR_UNKNOWN_COMMAND: _("Commande inconnue"),
	ERROR_IO: _("Erreur d'entrée/sortie"),
	ERROR_KB_INTERRUPT: _("Interuption au clavier"),
}

# define uptodate internals exceptions

class InvalidNbOfArgs(Exception) :
	pass

class NoVersionFound(Exception) :
	pass

class ModuleNotFoundException(Exception) :
	pass

class ModuleExistsException(Exception) :
	pass

class UnknownCommandException(Exception) :
	pass

class PropertyNotFoundException(Exception) :
	pass


# following functions are commands
# first line of docstring is used as command short description
# next lines are used in command description

def commandAdd(argv, conf, out) :
	"""Ajoute un nouveau module

	Add est utilisé pour ajouter un nouveau module. Un module posssède un nom et contient les informations nécessaires pour aller chercher les nouvelles versions :
	+ une URL d'un fichier ou d'un repertoire. Le fichier ou le répertoire peuvent être distant (site web, site ftp) ou local
	+ une expression régulière permettant de trouver les versions dans les informations récupérées grâce à l'URL précédente
	Vous pouvez également ajouter un commentaire pour décrire le module, pour garder la page d'accueil du programme dont vous voulez suivre la version, etc.
	Ces informations doivent être fournie sur la ligne de commande.

	Exemple :
        uptodate add zope http://www.zope.org/Products/ 'Download Zope (.{1,10})\\s*</a>' A leading open source application server"""
	
	parser = OptionParser(usage=_("uptodate [options] add [options] nom url regexp [commentaire]"), description=_(commandAdd.__doc__), formatter=UptodateCommandHelpFormatter())
	parser.add_option("-b", "--batch", action="store_true", dest="batch", help=_("ne pas poser de question"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("ajouter le module même si il existe déjà"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("afficher le module après l'avoir ajouté"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("affiche les options disponibles"))
	opts, args = parser.parse_args(argv)

	if opts.listOption :
		listOptions(parser)
		return 0
    
	if len(args) < 3 :
		raise InvalidNbOfArgs(parser.get_usage())

	module = args[0]
	url = args[1]
	regexp = args[2]
	comment = " ".join(args[3:])
	
	if not opts.force and conf.has_section(module) :
		if opts.batch or not yes(_("Voulez vous supprimer le module %s ?") % module, False) :
			raise ModuleExistsException(module)
		else :
			opts.force = True
	
	current = getVersions(module, url, regexp)
	
	# test if a version can be found
	if len(current) != 0 :
		if opts.force and conf.has_section(module) :
			conf.remove_section(module)
		conf.add_section(module)
		conf.set(module, 'url', url)
		conf.set(module, 'regexp', regexp)
		conf.set(module, 'comment', comment)
		updateVersions(conf, module, current)
		# conf.set(module, 'current', repr(current))
		
		if opts.verbose :
			printModule(conf, module, sys.stderr, True)
	else :
		# no version found... exit
		raise NoVersionFound()


def commandAuto(argv, conf, out) :
	"""Ajoute un nouveau module sans avoir à fournir d'expression régulière

	Auto est utilisé pour ajouter un nouveau module sans avoir a fournir l'expression régulière qui permet de récupérer les versions.
	Vous devez fournir :
	+ un nom. Si le nom est présent à l'URL fournie, il influencera le choix de l'expression régulière.
	+ une URL d'un fichier ou d'un repertoire. Le fichier ou le répertoire peuvent être distant (site web, site ftp) ou local
	+ un numéro de version présent à l'URL fournie. Ce numéro permet de trouver l'expression régulière qui sera utilisé pour obtenir les nouvelles versions.
	Vous pouvez également ajouter un commentaire pour décrire le module, pour garder la page d'accueil du programme dont vous voulez suivre la version, etc.
	Ces informations doivent être fournie sur la ligne de commande.

	Exemples :
	+ zope
	uptodate auto zope http://www.zope.org/Products/ 2.7.4
	
	+ InsightToolkit, depuis la page de téléchargement de sourceforge :
	uptodate auto InsightToolkit 'http://sourceforge.net/project/showfiles.php?group_id=108122&package_id=116777' 2.0.1
	
	+ jpackage non free files, depuis un répertoire ftp :
	uptodate auto jpackage ftp://sunsite.informatik.rwth-aachen.de/pub/Linux/jpackage/1.6/generic/SRPMS.non-free/ j2ee-connector-1.5-3jpp.nosrc.rpm
	
	+ jpackage releases, depuis un repertoire ftp :
	uptodate auto jpackage-release ftp://sunsite.informatik.rwth-aachen.de/pub/Linux/jpackage/ 1.6"""
	
	parser = OptionParser(usage=_("uptodate [options] auto [options] nom url version [commentaire]"), description=_(commandAuto.__doc__), formatter=UptodateCommandHelpFormatter())
	parser.add_option("-b", "--batch", action="store_true", dest="batch", help=_("ne pas poser de question"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("ajouter le module même si il existe déjà"))
	parser.add_option("-i", "--interactive", action="store_true", dest="choose", help=_("choisir une expression régulière dans la liste proposée par uptodate"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("afficher le module après l'avoir ajouté"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("affiche les options disponibles"))
	opts, args = parser.parse_args(argv)
	
	versionRegExp = r'([^<>\n\r]+)'

	if opts.listOption :
		listOptions(parser)
		return 0
    
	if len(args) < 3 :
		raise InvalidNbOfArgsException(parser.get_usage())

	module = args[0]
	url = args[1]
	version = args[2]
	comment = " ".join(args[3:])
	
	if not opts.force and conf.has_section(module) :
		if opts.batch or not yes(_("Voulez vous supprimer le module %s ?") % module, False) :
			raise ModuleExistsException(module)
		else :
			opts.force = True
	
	# load data which will be used to search regexp
	urlData = loadData(url)

	# find text around version string given by user
	bordersRegexps = []
	# text is keep from version to ', " or < (or >, depending of side)
	# versin string is escaped to avoid problem with regexp. Without escape, "2.7.4" can match "217a4" for example.
	bordersRegexps.append(('', r'([>"\'][^>"\']*)%s([^>"]{0,15}[<"\'])', ''))
	# for ftp listing
	bordersRegexps.append((r'[drwxls\-]{10}\s+' + r'\S+\s+' * 7, r'(\S*)%s(\S*)', ''))
	# finally, use what we can find
	bordersRegexps.append(('', '(.*)%s(.*)', ''))
		
	borders = []
	# select borders
	for (prefix, bRegexp, suffix) in bordersRegexps :
		borders = re.findall(prefix + bRegexp % re.escape(version) + suffix, urlData)
		if borders != [] :
			break
	
	if len(borders) == 0 :
		raise NoVersionFound()

	# generate regexp candidates, and select the best one
	candidates = set()
	regexp = ""
	for border in borders :
		lBorder, rBorder = border
		
		# remove part of border if version is found in it
		if version in lBorder :
			lBorder = lBorder[lBorder.find(version)+len(version):]
		if version in rBorder :
			rBorder = rBorder[:lBorder.find(version)]
			
		# escape characters so they can be used in regexp
		lBorder = re.escape(lBorder)
		rBorder = re.escape(rBorder)
		
		# create regexp candidate
		candidate = prefix + lBorder + versionRegExp + rBorder + suffix
	
		# finally, add regexp candidate to the list
		candidates.add(candidate)


	# sort canditates
	# best candidates have the module name near the version
	# find candidates with module name in it
	bestCandidates = [c for c in candidates if module in c]
	# define a function able to give distance from module to version
	def disModuleVersion(s) :
		vPos = s.find(versionRegExp)
		mPos = s.find(module)
		if vPos > mPos :
			return vPos - (mPos + len(module))
		else :
			return mPos - (vPos + len(versionRegExp))

	# define another method which add -length, so it can be used as a second sort parameter (largest is the best)
	def lenModuleVersion(s) :
		return (disModuleVersion(s), -len(s))
	
	# use this second function to sort bestCandidates
	# don't use it for python 2.3 : bestCandidates.sort(key=lenModuleVersion)
	bestCandidates = sorted(bestCandidates, key=lenModuleVersion)

	# sort the other candidate (largest is the best)	
	otherCandidates = sorted(candidates - set(bestCandidates), key=len, reverse=True)

	candidates = bestCandidates + otherCandidates
	regexp = candidates[0]
	
	if opts.choose :
		# ask to user to select a regexp
		print >> sys.stderr, _("Les expressions régulières disponibles sont :")
		for i, candidate in enumerate(candidates) :
			print >> sys.stderr, "%i. %s" % (i, candidate)
			print >> sys.stderr, '    %s' % repr(re.findall(candidate, urlData))
			print >> sys.stderr
		# get number
		import readline
		selectRegExp = -1
		while selectRegExp == -1 :
			try :
			        userAnwser = raw_input(_("Choisissez une expression régulière (0) :"))
				selectRegExp = int(userAnwser)
				if selectRegExp < 0 or selectRegExp >= len(candidates) :
					selectRegExp = -1
			except ValueError :
				if userAnwser == "" :
				    selectRegExp = 0
			except EOFError :
				# transform EOF in keyboard interrupt
				raise KeyboardInterrupt()
		# replace automatically selected regexp with user one
		regexp = candidates[selectRegExp]

	# get versions founds with selected regexp
	current = list(set(re.findall(regexp, urlData)))

	# test if a version can be found
	if len(current) != 0 :
		if opts.force and conf.has_section(module) :
			conf.remove_section(module)
		conf.add_section(module)
		conf.set(module, 'url', url)
		conf.set(module, 'regexp', regexp)
		conf.set(module, 'comment', comment)
		updateVersions(conf, module, current)
		# conf.set(module, 'current', repr(current))
		
		if opts.verbose :
			printModule(conf, module, sys.stderr, True)
	else :
		# no version found... exit
		raise NoVersionFound()


def commandCheck(argv, conf, out) :
	"""Cherche les nouvelles versions

	Check est utilisé pour chercher les nouvelles versions des modules donnés en paramètres. Par défaut, les nouvelles versions et les versions supprimées sont affichées.
	Les versions trouvées sont enregistrées afin de pouvoir afficher les modifications à la prochaine éxécution de cette commande.
	Vous pouvez exectuer cette commande périodiquement (avec cron par exemple) pour suivre l'évolution des versions.

	Exemple :
	uptodate check zope 
	zope : '2.7.5' ajoutée.
	zope : '2.7.4' supprimée."""
	
	parser = OptionParser(usage=_("uptodate [options] check [options] [nom] ..."), description=_(commandCheck.__doc__), formatter=UptodateCommandHelpFormatter())
	parser.add_option("-a", "--all", action="store_true", dest="all", help=_("rechercher les nouvelles versions de tous les modules"))
	parser.add_option("-A", "--added", action="store_true", dest="added", help=_("afficher les versions ajoutées depuis la dernière recherche"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("ignorer les modules inexistants"))
	parser.add_option("-r", "--removed", action="store_true", dest="removed", help=_("afficher les versions supprimées depuis la dernière recherche"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("afficher ce qui est fait"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("affiche les options et les modules disponibles"))
	opts, args = parser.parse_args(argv)

	if opts.listOption :
		listOptions(parser)
		listModules(conf)
		return 0

    
	if not opts.added and not opts.removed :
		# by default, both removed and added are displayed
		opts.added = True
		opts.removed = True
	
	if len(args) == 0 and not opts.all :
		# no module to check... print usage and exit
		raise InvalidNbOfArgs(parser.get_usage())

	if opts.all :
		modules = conf.sections()
	else :
		modules = set(args)
		wrongModules = modules - set(conf.sections())
		if wrongModules :
			if opts.force :
				modules -= wrongModules
			else :
				raise ModuleNotFoundException(wrongModules)


	for module in sorted(modules) :
		if opts.verbose :
			print >> sys.stderr, _("%s : Recherche de nouvelles versions.") % module
		# get module properties
		url = conf.get(module, 'url')
		regexp = conf.get(module, 'regexp').replace('\\\\', '\\')
		currentVersions = eval(conf.get(module, 'current'))
		# get new versions
		newVersions = getVersions(module, url, regexp)
		# test if a version can be found
		if len(newVersions) != 0 :
			updateVersions(conf, module, newVersions)
			# conf.set(module, 'current', repr(newVersions))
			
			added = set(newVersions) - set(currentVersions)
			removed = set(currentVersions) - set(newVersions)
			if added and opts.added :
				if len(added) == 1 :
					print >> out, _("%s : %s ajoutée.") % (module, repr(added.pop()))
				else :
					print >> out, _("%s : %s ajoutées.") % (module, andJoin(map(repr, added)))
			if removed and opts.removed :
				if len(removed) == 1 :
					print >> out, _("%s : %s supprimée.") % (module, repr(removed.pop()))
				else :
					print >> out, _("%s : %s supprimées.") % (module, andJoin(map(repr, removed)))
		else :
			# no version found
			print >> sys.stderr, _("Attention : aucune version trouvée pour %s. Les versions actuellement connues sont conservées.") % module
			# return
		

def commandEdit(argv, conf, out) :
	"""Modifie les propriétés d'un module

	Edit est utilisé pour modifier les propriétés d'un module. Les propriétés modifiables sont : url, regexp et comment. Si url ou regexp sont modifiées, uptodate vérifie qu'il peut obtenir des versions avant de valider les changements.

	Exemple :
	uptodate edit itk-app comment des applications utilisant InsightToolkit"""
	parser = OptionParser(usage=_("uptodate [options] edit [options] nom propriété [valeur]"), description=_(commandEdit.__doc__), formatter=UptodateCommandHelpFormatter())
	parser.add_option("-b", "--batch", action="store_true", dest="batch", help=_("ne pas poser de question"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("ne pas verifier que les nouvelles valeurs permettent de trouver des versions"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("afficher le module après avoir modifier le module"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("affiche les options et les modules disponibles"))
	opts, args = parser.parse_args(argv)

	if opts.listOption :
		listOptions(parser)
		listModules(conf)
		return 0
    
	if len(args) == 2 and not opts.batch :
		# interactive edit
		module, prop = args
		if module not in conf.sections() :
			raise ModuleNotFoundException(module)
		if not conf.has_option(module, prop) :
			raise PropertyNotFound(prop)

		import readline
		# arghhh
		# readline.insert_text() seems to so nothing :-(
		# how to set an initial value ??
		readline.insert_text(conf.get(module, prop))
		value = raw_input(_('%s value : ') % prop)
		
	elif len(args) >= 3 :
		# command line edit
		module = args[0]
		prop = args[1]
		value = " ".join(args[2:])
		if module not in conf.sections() :
			raise ModuleNotFoundException(wrongModules)
		if not conf.has_option(module, prop) :
			raise PropertyNotFound(prop)
		
	else :
		# invalid number of arguments !
		raise InvalidNbOfArgs(parser.get_usage())
	
	# modify prop value
	conf.set(module, prop, value)
	if opts.verbose :
		printModule(conf, module, sys.stderr, True)

	# test if everything is ok
	if not opts.force and prop in ["regexp", "url"] :
		current = getVersions(module, conf.get(module, 'url'), conf.get(module, 'regexp'))
		if len(current) == 0 :
			raise NoVersionFound()
		updateVersions(conf, module, current)
		# conf.set(module, 'current', repr(current))



def commandRemove(argv, conf, out) :
	"""Supprimer des modules

	Remove est utilisé pour supprimer les modules fournis en paramètre.

	Exemple :
	uptodate remove itk-app"""
	
	parser = OptionParser(usage=_("uptodate [options] remove [options] [nom] ..."), description=_(commandRemove.__doc__), formatter=UptodateCommandHelpFormatter())
	parser.add_option("-a", "--all", action="store_true", dest="all", help=_("supprimer tous les modules"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("supprimer les modules sans poser de question et ignorer les modules inexistants"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("afficher les modules supprimés"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("afficher les options et les modules disponibles"))
	opts, args = parser.parse_args(argv)

	if opts.listOption :
		listOptions(parser)
		listModules(conf)
		return 0

    
	if len(args) == 0 and not opts.all :
		raise InvalidNbOfArgs(parser.get_usage())
	
	if opts.all :
		modules = conf.sections()
	else :
		modules = set(args)
		wrongModules = modules - set(conf.sections())
		if wrongModules :
			if opts.force :
				modules -= wrongModules
			else :
				raise ModuleNotFoundException(wrongModules)


	for module in sorted(modules) :
		if opts.force or yes(_("Supprimer %s ?") % module, False) :
			if opts.verbose :
				printModule(conf, module, sys.stderr, True)
			conf.remove_section(module)
		

def commandDisplay(argv, conf, out) :
	"""Affiche les informations sur les modules

	Display est utilisé pour afficher les informations sur les modules fournis en paramètre.

	Exemple :
	uptodate display itk-app"""
	
	parser = OptionParser(usage="uptodate [options] display [options] [nom] ...", description=_(commandDisplay.__doc__), formatter=UptodateCommandHelpFormatter())
	parser.add_option("-a", "--all", action="store_true", dest="all", help=_("afficher tous les modules"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("ignorer les modules inexistants"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("afficher plus d'informations"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("afficher les options et les modules disponibles"))
	opts, args = parser.parse_args(argv)

	if opts.listOption :
		listOptions(parser)
		listModules(conf)
		return 0
    
    
	if len(args) == 0 and not opts.all :
		raise InvalidNbOfArgs(parser.get_usage())
	
	if opts.all :
		modules = conf.sections()
	else :
		modules = set(args)
		wrongModules = modules - set(conf.sections())
		if wrongModules :
			if opts.force :
				modules -= wrongModules
			else :
				raise ModuleNotFoundException(wrongModules)


	for module in sorted(modules) :
		printModule(conf, module, out, opts.verbose)


def commandCopy(argv, conf, out) :
	"""Copie un module

	Copy est utilisé pour copier un module.

	Exemple :
	uptodate copy itk-app InsightToolkit-Applications"""
	
	parser = OptionParser(usage=_("uptodate [options] copy nom nom"), description=_(commandCopy.__doc__), formatter=UptodateCommandHelpFormatter())
	parser.add_option("-b", "--batch", action="store_true", dest="batch", help=_("ne pas de poser de question"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("copier le module même si le nom existe déjà"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("afficher le module copié"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("afficher les options et les modules disponibles"))
	opts, args = parser.parse_args(argv)

	if opts.listOption :
		listOptions(parser)
		listModules(conf)
		return 0
    
	if len(args) != 2 :
		raise InvalidNbOfArgs(parser.get_usage())

	module, new = args
	if module not in conf.sections() :
		raise ModuleNotFoundException(module)

	if not opts.force and conf.has_section(new) :
		if opts.batch or not yes(_("Voulez-vous supprimer le module %s ?") % new, False) :
			raise ModuleExistsException(new)
		else :
			opts.force = True
	
	# remove new section if it already exist and --force is used
	if opts.force and  conf.has_section(new) :
		conf.remove_section(new)

	conf.add_section(new)
	for prop in conf.options(module) :
		conf.set(new, prop, conf.get(module, prop))
	if opts.verbose :
		printModule(conf, new, sys.stderr, True)


	
	
def commandRename(argv, conf, out) :
	"""Renomme un module

	Rename est utilisé pour renommer un module

	Exemple :
	uptodate rename itk-app InsightToolkit-Applications"""
	
	parser = OptionParser(usage=_("uptodate [options] rename nom nouveau_nom"), description=_(commandRename.__doc__), formatter=UptodateCommandHelpFormatter())
	parser.add_option("-b", "--batch", action="store_true", dest="batch", help=_("ne pas poser de question"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("renommer le module même si le nom existe déjà"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("afficher le module renommé"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("afficher les options et les modules disponibles"))
	opts, args = parser.parse_args(argv)

	if opts.listOption :
		listOptions(parser)
		listModules(conf)
		return 0
    
	if len(args) != 2 :
		raise InvalidNbOfArgs(parser.get_usage())

	module, new = args
	if module not in conf.sections() :
		raise ModuleNotFoundException(module)
	
	# remove new section if it already exist and --force is used
	if not opts.force and conf.has_section(new) :
		if opts.batch or not yes(_("Voulez-vous supprimer le module %s ?") % new, False) :
			raise ModuleExistsException(new)
		else :
			opts.force = True
	
	# remove new section if it already exist and --force is used
	if opts.force and  conf.has_section(new) :
		conf.remove_section(new)

	conf.add_section(new)
	for prop in conf.options(module) :
		conf.set(new, prop, conf.get(module, prop))
	conf.remove_section(module)
	if opts.verbose :
		printModule(conf, new, sys.stderr, True)

	
	
def commandImport(argv, conf, out) :
	"""Importe des modules

	Import est utilisé pour importer des modules.

	Exemple :
	uptodate import config"""
	
	parser = OptionParser(usage=_("uptodate [options] import fichier [name] ..."), description=_(commandRename.__doc__), formatter=UptodateCommandHelpFormatter())
	parser.add_option("-a", "--all", action="store_true", dest="all", help=_("importer tous les modules du fichier"))
	parser.add_option("-b", "--batch", action="store_true", dest="batch", help=_("ne pas poser de question"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("importer les modules même si les noms existent déjà"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("afficher les modules importés"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("afficher les options disponibles"))
	opts, args = parser.parse_args(argv)

	if opts.listOption :
		listOptions(parser)
		return 0
    
        # load config to import
	import ConfigParser
	importConf = ConfigParser.SafeConfigParser()
	importFile = file(args[0])
	importConf.readfp(importFile)
	importFile.close()

	# module to import
	if len(args) <= 1 and not opts.all :
		raise InvalidNbOfArgs(parser.get_usage())
	
	if opts.all :
		modules = importConf.sections()
	else :
		modules = set(args[1:])
		wrongModules = modules - set(importConf.sections())
		if wrongModules :
			if opts.force :
				modules -= wrongModules
			else :
				raise ModuleNotFoundException(wrongModules)
	
	
	# now iterate sections
	for module in sorted(modules) :
		imp = True
		if conf.has_section(module) :
			if opts.force :
				conf.remove_section(module)
			elif opts.batch :
				raise ModuleExistsException(module)
			elif yes(_("Do you want to remove existing %s module?") % module, False) :
				conf.remove_section(module)
			else :
				imp = False
		if imp :
			# copy section
			conf.add_section(module)
			for prop in importConf.options(module) :
				conf.set(module, prop, importConf.get(module, prop))
			if opts.verbose :
				printModule(conf, module, sys.stderr, True)

	return 0


	
	
def commandExport(argv, conf, out) :
	"""Exporte des modules

	Export est utilisé pour exporter des modules.

	Ex :
	uptodate -o config export -a
	uptodate export itk-app > config"""
	
	parser = OptionParser(usage=_("uptodate [options] export [name] ..."), description=_(commandRename.__doc__), formatter=UptodateCommandHelpFormatter())
	parser.add_option("-a", "--all", action="store_true", dest="all", help=_("exporter tous les modules"))
	parser.add_option("-f", "--force", action="store_true", dest="force", help=_("ignorer les modules inexistant"))
	parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help=_("afficher les modules exportés"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("afficher les options et les modules disponibles"))
	opts, args = parser.parse_args(argv)

	if opts.listOption :
		listOptions(parser)
		listModules(conf)
		return 0
    
	import ConfigParser
	exportConf = ConfigParser.SafeConfigParser()

	if len(args) == 0 and not opts.all :
		raise InvalidNbOfArgs(parser.get_usage())
	
	if opts.all :
		modules = conf.sections()
	else :
		modules = set(args)
		wrongModules = modules - set(conf.sections())
		if wrongModules :
			if opts.force :
				modules -= wrongModules
			else :
				raise ModuleNotFoundException(wrongModules)
	
	
	# now iterate modules
	for module in sorted(modules) :
		# copy section
		exportConf.add_section(module)
		for prop in conf.options(module) :
			exportConf.set(module, prop, conf.get(module, prop))
		if opts.verbose :
			printModule(exportConf, module, sys.stderr, True)

	exportConf.write(out)
	return 0


	
	
COMMANDS = [(['add'], commandAdd),
	    (['check'], commandCheck),
	    (['edit'], commandEdit),
	    (['remove', 'rm', 'del'], commandRemove),
	    (['display'], commandDisplay),
	    (['copy', 'cp'], commandCopy),
	    (['rename', 'mv'], commandRename),
	    (['auto'], commandAuto),
	    (['import'], commandImport),
	    (['export'], commandExport),
	    ]




# helper functions

def printModule(conf, module, out, verbose=False) :
	"""
	printModule(conf, module, out, verbose)

	print module info to out file. Infos comes from conf object.
	"""
	url = conf.get(module, 'url')
	regexp = conf.get(module, 'regexp').replace('\\\\', '\\')
	current = eval(conf.get(module, 'current'))
	comment = conf.get(module, 'comment')
	if conf.has_option(module, 'added') :
		added = eval(conf.get(module, 'added'))
	else :
		added = {}
	if conf.has_option(module, 'removed') :
		removed = eval(conf.get(module, 'removed'))
	else :
		removed = {}
	
	if verbose :
		template = _(
"""%(module)s
  commentaire : %(comment)s
  URL : %(url)s
  expression régulière : %(regexp)s
  versions actuelles : %(current)s
  historique : %(history)s
""")
		
		if added or removed:
			# create a list with added and removed versions
			hList = []
			for t, versions in added.iteritems() :
				hList.append((t, True))
			for t, versions in removed.iteritems() :
				hList.append((t, False))
			historyString = ""
			for t, a in sorted(hList, reverse=True) :
				if a :
					historyString += _('\n    + %s : %s') % (makeTime(t), andJoin(map(repr, added[t])))
				else :
					historyString += _('\n    - %s : %s') % (makeTime(t), andJoin(map(repr, removed[t])))
		else :
			historyString = _('aucun')
		
		if removed :
			removedString = ""	
			for t in sorted(removed.keys(), reverse=True) :
				removedString += _('\n      - %s : %s') % (makeTime(t), andJoin(map(repr, removed[t])))
		else :
			removedString = _('aucune')
		
		print >> out, template % {'module': module, 'comment': comment, 'url': url, 'regexp': regexp, 'current': andJoin(map(repr, current)), 'history': historyString}
	else :
		s = module
		if comment :
			s += " (%s)" % comment
		if added :
			lastTime = sorted(added.keys(), reverse=True)[0]
			s += '  + %s (%s)' % (andJoin(map(repr, added[lastTime])), makeTime(lastTime))
		if removed :
			lastTime = sorted(removed.keys(), reverse=True)[0]
			s += '  - %s (%s)' % (andJoin(map(repr, removed[lastTime])), makeTime(lastTime))
		
		print >> out, s
		
def makeTime(t) :
	import time
	template = _('%(d)i/%(M)i/%(y)i %(h)ih%(m)i')
	tTuple = time.gmtime(t)
	tDict = {'y': tTuple[0], 'M': tTuple[1], 'd': tTuple[2], 'h': tTuple[3], 'm': tTuple[4], 's': tTuple[5]}
	return template % tDict

def andJoin(iterable) :
	last = _(" et ")
	sep = _(", ")
	if len(iterable) == 0 :
		msg = ""
	elif len(iterable) == 1 :
		msg = iterable[0]
	else :
		msg = sep.join(iterable[:-1]) + last + iterable[-1]
	return msg


def yes(question, default=None) :
	import readline
	if default != None and default :
		values = _('Y/n')
	elif default != None and not default :
		values = _('y/N')
	else :
		values = _('y/n')
		
	try :
		ret = raw_input("%s (%s) " % (question, values)).lower()
	except EOFError :
		# transform EOF in keyboard interrupt
		raise KeyboardInterrupt()
	
	if ret in [_("n"), _("no")] :
		return False
	if ret in [_("y"), _("yes")] :
		return True
	if default != None and ret == "" :
		return default
	# invalid answer... reask the question
	return yes(question, default)


def listOptions(parser) :
	for opt in parser.option_list :
		print opt._long_opts[0]


def listModules(conf) :
	for module in conf.sections() :
		print module
	

def loadData(url) :
    try :
	    urlFile = urllib.urlopen(url)
	    urlData = urlFile.read()
	    urlFile.close()
    except IOError, e :
	    if e.errno == 21 :
		    # url is a directory !
		    # we use 'ls -l' to have the same output than a ftp dir
		    import commands
		    (retVal, urlData) = commands.getstatusoutput('ls -l %s' % url)
		    if retVal != 0 :
			    # something goes wrong...
			    raise urlData
	    else :
		    # re-throw exception :-)
		    raise e
    return urlData


def getVersions(module, url, regexp) :
    urlData = loadData(url)
    new = re.findall(regexp, urlData)
    return list(set(new))


def updateVersions(conf, name, newVersions) :
	import time
	
	if not conf.has_option(name, 'current') :
		conf.set(name, 'current', repr([]))
	if not conf.has_option(name, 'added') :
		conf.set(name, 'added', repr({}))
	if not conf.has_option(name, 'removed') :
		conf.set(name, 'removed', repr({}))
	
	current = set(eval(conf.get(name, 'current')))
	added = eval(conf.get(name, 'added'))
	removed = eval(conf.get(name, 'removed'))
	
	newAdded = list(set(newVersions) - current)
	newRemoved = list(current - set(newVersions))
	newVersions = list(newVersions)
	# print current, added, removed
	# print newVersions, newAdded, newRemoved

	currentTime = time.time()

	conf.set(name, 'current', repr(newVersions))
	if newAdded != [] :
		added[currentTime] = newAdded
		conf.set(name, 'added', repr(added))
	if newRemoved != [] :
		removed[currentTime] = newRemoved
		conf.set(name, 'removed', repr(removed))
	

def file(fName, output=False, notNone=False, append=False) :
        """Renvoi un fichier en fonction du nom de fichier passé en paramètre.
        
        fName est le chemin d'acces complet a un fichier.
        fName = "-" est interprété comme l'entrée (ou la sortie, si output=True) standard.
        output = True indique que le ficher doit etre ouvert en ecriture
        notNone = True provoque le renvoi d'un fichier ouvert sur /dev/null plutot que None quand fName = ""
        append provoque l'ouverture du ficheir en mode append. Doit etre utilisé avec output = True
        """
        if append :
                wMode = "a"
        else :
                wMode = "w"
        
        #le nom de fichier est vide...
        if fName == "" :
                if notNone :
                        if output :
                                return file("/dev/null", wMode)
                        else :
                                return file("/dev/null")
                else :
                        return None
        
        elif fName == "-" :
                #la sortie ou l'entree standard
                if output :
                        return sys.stdout
                else :
                        return sys.stdin
        else :
                # un fichier normal
                if output :
                        return __builtin__.file(fName, wMode)
                else :
                        return __builtin__.file(fName)




class UptodateHelpFormatter(IndentedHelpFormatter) :
	def format_description(self, description) :
		return description


class UptodateCommandHelpFormatter(IndentedHelpFormatter) :
	def format_description(self, description) :
		if not description :
			return ""
		import textwrap
		desc_width = self.width - self.current_indent
		indent = " "*self.current_indent
		newDesc = ""
		for line in description.splitlines() :
			newDesc += textwrap.fill(line.strip(),
						 desc_width,
						 initial_indent=indent+'  ',
						 subsequent_indent=indent) + "\n"
		return newDesc



def main(argv) :
	# generate command description
	formattedCommands = {}
	fill = 0
	for names, function in COMMANDS :
		namesString = names[0]
		if len(names) > 1 :
			namesString += ' (%s)' % ', '.join(names[1:])
		formattedCommands[namesString] = function.__doc__.splitlines()[0].strip()
		namesLen = len(namesString)
		if namesLen > fill :
			fill = namesLen
	comString = ""
	fill = max([len(c) for c in formattedCommands.keys()])
	for names in sorted(formattedCommands.keys()) :
                comString += "  %s  %s\n" % (names.ljust(fill), formattedCommands[names])


	# generate exit code description
	errString = ""
	fill = max([len(str(c)) for c in ERRORS.keys()])
	for error in sorted(ERRORS.keys()) :
		errString += _("  %s  %s\n") % (str(error).ljust(fill), ERRORS[error])
		
	# generate complete description
	fullDesc = DESCRIPTION % (comString, errString)

	# and create option parser
	parser = OptionParser(usage=USAGE,
			      description=fullDesc,
			      version="uptodate %s" % VERSION,
			      formatter=UptodateHelpFormatter())
	parser.disable_interspersed_args()
	parser.add_option("-c", "--config-file", dest="configPath", default=os.path.expanduser("~/.uptodate"), metavar=_("FICHIER"), help=_("fichier de configuration (%default)"))
	parser.add_option("-d", "--dry-run", action="store_true", dest="dryRun", help=_("ne pas sauvegarder les changements"))
	parser.add_option("-o", "--output", dest="outputPath", default="-", metavar=_("FICHIER"), help=_("ecrire dans FICHIER (sortie standard par défaut)"))
	parser.add_option("--list-option", action="store_true", dest="listOption", help=_("afficher les options et les commandes disponibles"))
	opts, args = parser.parse_args()

	# create a dict to have easy access to command names and functions
	commands = {}
	for names, function in COMMANDS :
		for name in names :
			commands[name] = function
        
	if opts.listOption :
		listOptions(parser)
		# also display commands !
		for command in commands.keys() :
			print command
		return
    
	if len(args) > 0 :
		command = args[0]
		args = args[1:]
		if command not in commands.keys() :
			raise UnknownCommandException(command)
	else:
		parser.print_usage()
		raise InvalidNbOfArgs()
	
	
	# load config in a file to be able to load it from stdin
	import ConfigParser
	conf = ConfigParser.SafeConfigParser()
	try :
		# try to load config
		confFile = file(opts.configPath)
	except :
		# load fail... try to create it
		file(opts.configPath, True).close()
		confFile = file(opts.configPath)
	conf.readfp(confFile)
	confFile.close()

	# set output file
	out = file(opts.outputPath, True)
	
	# execute command
	retVal = commands[command](args, conf, out)
	
	# save config file, if needed
	if not opts.dryRun :
		confFile = file(opts.configPath, 'w')
		conf.write(confFile)
		confFile.close()

	return 0






if __name__ == '__main__':
	import sys
	try :
		sys.exit(main(sys.argv[1:]))
		
	except IOError, e:
		sys.stderr.write(sys.argv[0]+": ")
		if e.filename :
			sys.stderr.write(e.filename+": ")
		sys.stderr.write(str(e.strerror)+"\n")
		sys.exit(ERROR_IO)

	except KeyboardInterrupt, e :
		sys.stderr.write(str(e)+"\n")
		sys.exit(ERROR_KB_INTERRUPT)
		
	except InvalidNbOfArgs, e :
		sys.exit(ERROR_INVALID_NB_OF_ARGS)

	except ModuleExistsException, e :
		print >> sys.stderr, _("Erreur : Le module %s existe déjà.") % e.args[0]
		sys.exit(ERROR_MODULE_EXISTS)

	except NoVersionFound, e :
		print >> sys.stderr, _("Erreur : Aucune version trouvée")
		sys.exit(ERROR_NO_VERSION_FOUND)

	except ModuleNotFoundException, e :
		sing = _("Erreur : Le module %s n'existe pas.")
		plur = _("Erreur : Les modules % n'existent pas.")
		args = e.args[0]
		if isinstance(args, str) :
			msg = sing % args
		elif len(args) == 1 :
			args = list(args)
			msg = sing % args[0]
		else :
			args = list(args)
			msg = plur % andjoin(list(args))
		print >> sys.stderr, msg
		sys.exit(ERROR_MODULE_NOT_FOUND)

	except PropertyNotFoundException, e :
		print >> sys.stderr, _("Erreur : La propriété %s n'existe pas.") % e.args[0]
		sys.exit(ERROR_PROPERTY_NOT_FOUND)

	except UnknownCommandException, e :
		print >> sys.stderr, _("Erreur : La commande %s n'existe pas.") % e.args[0]
		sys.exit(ERROR_UNKNOWN_COMMAND)
